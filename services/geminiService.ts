import { GoogleGenAI, GenerateContentResponse } from "@google/genai";
import { AuditStatus, AuditReport } from "../types";

export class GeminiService {
  private ai: GoogleGenAI;

  constructor() {
    // ì—¬ê¸°ê°€ í•µì‹¬ ë³€ê²½ ì‚¬í•­ì…ë‹ˆë‹¤! Vercelì— ì„¤ì •í•œ ì´ë¦„ê³¼ ë˜‘ê°™ì´ ë§ì·„ìŠµë‹ˆë‹¤.
    const apiKey = import.meta.env.VITE_GOOGLE_API_KEY || '';
    if (!apiKey) {
      console.error("API Key is missing! Check .env or Vercel settings.");
    }
    this.ai = new GoogleGenAI({ apiKey: apiKey });
  }

  async runAudit(regulation: string, scenario: string, useSearch: boolean): Promise<AuditReport> {
    const prompt = `
      You are a high-precision Compliance Auditor. Your task is to perform a clinical analysis of a [Scenario] against a [Regulation].
      
      [Context]
      The regulation text might contain tabular data represented as CSV or text blocks. Pay close attention to row/column alignment.
      
      [Regulation]:
      ${regulation}
      
      [Scenario]:
      ${scenario}
      
      CRITICAL INSTRUCTIONS:
      1. ABSOLUTE ACCURACY: You must quote the relevant clauses from the regulation text EXACTLY as they appear. Do not paraphrase.
      2. LOGICAL RIGOR: Use step-by-step reasoning (Chain of Thought) to determine if the scenario violates any part of the regulation.
      3. STATUS: Determine if the result is "Violation", "Compliant", or "Uncertain".
      4. HIGHLIGHTING: In the "ìƒì„¸ ë¶„ì„" section, wrap the specific words or phrases that trigger a violation in <span class="highlight-red">text</span>.
      
      Output Format (Must follow strictly):
      ### âš–ï¸ íŒì • ê²°ê³¼: [ìœ„ë°˜ / ì í•© / íŒë‹¨ ë¶ˆê°€]
      ### ğŸ“œ ê´€ë ¨ ê·¼ê±° ì¡°í•­
      > (ê·œì • ì›ë¬¸ ì¡°í•­ ì¸ìš© - ì˜¤íƒ€ ì—†ì´ ì •í™•í•˜ê²Œ)
      ### ğŸ” ìƒì„¸ ë¶„ì„
      - (ì‚¬ì•ˆê³¼ ê·œì •ì„ ëŒ€ì¡°í•˜ì—¬ ìœ„ë°˜/ì í•© ì—¬ë¶€ë¥¼ ë…¼ë¦¬ì ìœ¼ë¡œ ì„¤ëª…)
      ### ğŸ’¡ ì¡°ì¹˜ ê¶Œê³  ì‚¬í•­
      - (ìœ„ë°˜ ì‹œ í•´ê²°ì±… ë˜ëŠ” í–¥í›„ ë°©ì§€ì±… ì œì•ˆ)
    `;

    // Using gemini-2.0-flash for faster response and stability (changed from preview)
    const response = await this.ai.models.generateContent({
      model: 'gemini-2.0-flash',
      contents: prompt,
      config: {
        // tools: useSearch ? [{ googleSearch: {} }] : undefined, // search tool disabled for stability
      },
    });

    const text = response.text || "No response generated.";
    
    let status = AuditStatus.UNCERTAIN;
    if (text.includes('ìœ„ë°˜') || text.toLowerCase().includes('violation')) status = AuditStatus.VIOLATION;
    else if (text.includes('ì í•©') || text.toLowerCase().includes('compliant')) status = AuditStatus.COMPLIANT;

    const groundingChunks = response.candidates?.[0]?.groundingMetadata?.groundingChunks;
    const urls = groundingChunks?.map((chunk: any) => ({
      uri: chunk.web?.uri || chunk.maps?.uri,
      title: chunk.web?.title || chunk.maps?.title || "Reference"
    })).filter((u: any) => u.uri);

    return {
      status,
      rawMarkdown: text,
      groundingUrls: urls,
    };
  }

  async editImage(base64Image: string, prompt: string): Promise<string> {
    const cleanBase64 = base64Image.split(',')[1] || base64Image;
    
    const response = await this.ai.models.generateContent({
      model: 'gemini-2.0-flash',
      contents: {
        parts: [
          {
            inlineData: {
              data: cleanBase64,
              mimeType: 'image/png',
            },
          },
          {
            text: prompt,
          },
        ],
      },
    });

    for (const part of response.candidates?.[0]?.content?.parts || []) {
      if (part.inlineData) {
        return `data:image/png;base64,${part.inlineData.data}`;
      }
    }

    throw new Error("No image generated by Gemini");
  }
}
