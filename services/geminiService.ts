
import { GoogleGenAI, GenerateContentResponse } from "@google/genai";
import { AuditStatus, AuditReport } from "../types";

export class GeminiService {
  private ai: GoogleGenAI;

  constructor() {
    this.ai = new GoogleGenAI({ apiKey: process.env.API_KEY || '' });
  }

  async runAudit(regulation: string, scenario: string, useSearch: boolean): Promise<AuditReport> {
    const prompt = `
      You are a high-precision Compliance Auditor. Your task is to perform a clinical analysis of a [Scenario] against a [Regulation].
      
      [Context]
      The regulation text might contain tabular data represented as CSV or text blocks. Pay close attention to row/column alignment.
      
      [Regulation]:
      ${regulation}
      
      [Scenario]:
      ${scenario}
      
      CRITICAL INSTRUCTIONS:
      1. ABSOLUTE ACCURACY: You must quote the relevant clauses from the regulation text EXACTLY as they appear. Do not paraphrase.
      2. LOGICAL RIGOR: Use step-by-step reasoning (Chain of Thought) to determine if the scenario violates any part of the regulation.
      3. STATUS: Determine if the result is "Violation", "Compliant", or "Uncertain".
      4. HIGHLIGHTING: In the "ÏÉÅÏÑ∏ Î∂ÑÏÑù" section, wrap the specific words or phrases that trigger a violation in <span class="highlight-red">text</span>.
      
      Output Format (Must follow strictly):
      ### ‚öñÔ∏è ÌåêÏ†ï Í≤∞Í≥º: [ÏúÑÎ∞ò / Ï†ÅÌï© / ÌåêÎã® Î∂àÍ∞Ä]
      ### üìú Í¥ÄÎ†® Í∑ºÍ±∞ Ï°∞Ìï≠
      > (Í∑úÏ†ï ÏõêÎ¨∏ Ï°∞Ìï≠ Ïù∏Ïö© - Ïò§ÌÉÄ ÏóÜÏù¥ Ï†ïÌôïÌïòÍ≤å)
      ### üîç ÏÉÅÏÑ∏ Î∂ÑÏÑù
      - (ÏÇ¨ÏïàÍ≥º Í∑úÏ†ïÏùÑ ÎåÄÏ°∞ÌïòÏó¨ ÏúÑÎ∞ò/Ï†ÅÌï© Ïó¨Î∂ÄÎ•º ÎÖºÎ¶¨Ï†ÅÏúºÎ°ú ÏÑ§Î™Ö)
      ### üí° Ï°∞Ïπò Í∂åÍ≥† ÏÇ¨Ìï≠
      - (ÏúÑÎ∞ò Ïãú Ìï¥Í≤∞Ï±Ö ÎòêÎäî Ìñ•ÌõÑ Î∞©ÏßÄÏ±Ö Ï†úÏïà)
    `;

    // Using gemini-3-pro-preview for complex reasoning and higher accuracy
    const response = await this.ai.models.generateContent({
      model: 'gemini-3-pro-preview',
      contents: prompt,
      config: {
        tools: useSearch ? [{ googleSearch: {} }] : undefined,
        thinkingConfig: { thinkingBudget: 4000 } // Reserve budget for complex reasoning
      },
    });

    const text = response.text || "No response generated.";
    
    let status = AuditStatus.UNCERTAIN;
    if (text.includes('ÏúÑÎ∞ò') || text.toLowerCase().includes('violation')) status = AuditStatus.VIOLATION;
    else if (text.includes('Ï†ÅÌï©') || text.toLowerCase().includes('compliant')) status = AuditStatus.COMPLIANT;

    const groundingChunks = response.candidates?.[0]?.groundingMetadata?.groundingChunks;
    const urls = groundingChunks?.map((chunk: any) => ({
      uri: chunk.web?.uri || chunk.maps?.uri,
      title: chunk.web?.title || chunk.maps?.title || "Reference"
    })).filter((u: any) => u.uri);

    return {
      status,
      rawMarkdown: text,
      groundingUrls: urls,
    };
  }

  async editImage(base64Image: string, prompt: string): Promise<string> {
    const cleanBase64 = base64Image.split(',')[1] || base64Image;
    
    const response = await this.ai.models.generateContent({
      model: 'gemini-2.5-flash-image',
      contents: {
        parts: [
          {
            inlineData: {
              data: cleanBase64,
              mimeType: 'image/png',
            },
          },
          {
            text: prompt,
          },
        ],
      },
    });

    for (const part of response.candidates?.[0]?.content?.parts || []) {
      if (part.inlineData) {
        return `data:image/png;base64,${part.inlineData.data}`;
      }
    }

    throw new Error("No image generated by Gemini");
  }
}
